<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Lorenz</title>
  </head>
  <body>
    <div id="canvas-holder" style="width: 600px; height: 400px; margin: 0 auto; border: 1px solid black;">
      <canvas id="canvas" width="600" height="400">
      </canvas>
    </div>
  </body>

<script>

var ctx = document.getElementById('canvas').getContext('2d');
ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2);

var piramid_vertex = [[30, 30, 0], [30, -30, 0], [-30, -30, 0], [-30, 30, 0], [0, 0, 30]];
var piramid_edges  = {
  0: [1, 3, 4],
  1: [2, 4],
  2: [3, 4],
  3: [4]
};

var e_z = 1;
var e_x = 0, e_y = 0;
var camera = {
  x: 10, y: 10, z: 2,
  ang: {
    x: 2*(Math.PI/180), y: 0.4*(Math.PI/180), z: 30*(Math.PI/180)
  }
};


function projection (a) {
  var d = {
    x: Math.cos(camera.ang.y) * (Math.sin(camera.ang.z) * (a.y - camera.y) + Math.cos(camera.ang.z) * (a.x - camera.x)) - Math.sin(camera.ang.y) * (a.z - camera.z),
    y: Math.sin(camera.ang.x) * (Math.cos(camera.ang.y) * (a.z - camera.z) + Math.sin(camera.ang.y) * (Math.sin(camera.ang.z) * (a.y - camera.y) + Math.cos(camera.ang.z) * (a.x - camera.x))) + Math.cos(camera.ang.x) * (Math.cos(camera.ang.z) * (a.y - camera.y) - Math.sin(camera.ang.z) * (a.x - camera.x)),
    z: Math.cos(camera.ang.x) * (Math.cos(camera.ang.y) * (a.z - camera.z) + Math.sin(camera.ang.y) * (Math.sin(camera.ang.z) * (a.y - camera.y) + Math.cos(camera.ang.z) * (a.x - camera.x))) - Math.sin(camera.ang.x) * (Math.cos(camera.ang.z) * (a.y - camera.y) - Math.sin(camera.ang.z) * (a.x - camera.x))
  };

  return d;
} 

for(var i in piramid_vertex){
  //ctx.beginPath();
  var cur_point = piramid_vertex[i];
  cur_point = projection({x: cur_point[0], y: cur_point[1], z: cur_point[2]});
  console.log(cur_point);

  var cur_point_2d = [(cur_point.x - e_x) * e_z/cur_point.z, (cur_point.y - e_y) * e_z/cur_point.z];

  for(var j in piramid_edges[i]){
    var next_point = piramid_vertex[piramid_edges[i][j]];
    next_point = projection({x: next_point[0], y: next_point[1], z: next_point[2]});
    var next_point_2d = [(next_point.x - e_x) * e_z/next_point.z, (next_point.y - e_y) * e_z/next_point.z];

    ctx.moveTo( cur_point_2d[0], cur_point_2d[1] );
    ctx.lineTo( next_point_2d[0], next_point_2d[1] );
    ctx.stroke();
  }
}

function pointView( point ){
  return [(point.x - e_x) * e_z/point.z, (point.y - e_y) * e_z/point.z];
}

ctx.beginPath();
ctx.moveTo( pointView(projection({x: -400, y: 0, z: 0}))[0], pointView(projection({x: -400, y: 0, z: 0}))[1]);
ctx.lineTo( pointView(projection({x: 400, y: 0, z: 0}))[0], pointView(projection({x: 400, y: 0, z: 0}))[1]);
ctx.stroke();

ctx.beginPath();
ctx.moveTo( pointView(projection({x: 0, y: -400, z: 0}))[0], pointView(projection({x: 0, y: -400, z: 0}))[1] );
ctx.lineTo( pointView(projection({x: 0, y: 400, z: 0}))[0], pointView(projection({x: 0, y: 400, z: 0}))[1] );
ctx.stroke();

ctx.beginPath();
ctx.moveTo( pointView(projection({x: 0, y: 0, z: -400}))[0], pointView(projection({x: 0, y: 0, z: -400}))[1] );
ctx.lineTo( pointView(projection({x: 0, y: 0, z: 400}))[0], pointView(projection({x: 0, y: 0, z: 400}))[1] );
ctx.stroke();

/*
ctx.beginPath();
ctx.moveTo(0, 0);
ctx.lineTo(10, 10);
ctx.stroke();
*/
</script>
</html>
